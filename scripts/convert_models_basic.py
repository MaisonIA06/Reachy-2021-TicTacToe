#!/usr/bin/env python3
"""
Script pour cr√©er des mod√®les TFLite ultra-compatibles (compatible avec anciennes versions)
"""

import os
import sys
import numpy as np

try:
    import tensorflow as tf
except ImportError:
    print("‚ùå TensorFlow n'est pas install√©.")
    print("Installez-le avec: pip install tensorflow")
    sys.exit(1)

print("="*70)
print("Cr√©ation de mod√®les TFLite ultra-compatibles")
print(f"TensorFlow version: {tf.__version__}")
print("="*70)
print()

# Chemins
script_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(script_dir)
models_dir = os.path.join(project_dir, 'reachy_tictactoe', 'models')

print(f"üìÅ R√©pertoire des mod√®les: {models_dir}")
print()


def create_simple_model(num_classes, input_shape=(224, 224, 3)):
    """
    Cr√©e un mod√®le CNN simple sans MobileNet (plus compatible)
    """
    model = tf.keras.Sequential([
        tf.keras.layers.InputLayer(input_shape=input_shape),
        
        # Bloc 1
        tf.keras.layers.Conv2D(16, 3, activation='relu', padding='same'),
        tf.keras.layers.MaxPooling2D(2),
        tf.keras.layers.Dropout(0.2),
        
        # Bloc 2
        tf.keras.layers.Conv2D(32, 3, activation='relu', padding='same'),
        tf.keras.layers.MaxPooling2D(2),
        tf.keras.layers.Dropout(0.2),
        
        # Bloc 3
        tf.keras.layers.Conv2D(64, 3, activation='relu', padding='same'),
        tf.keras.layers.GlobalAveragePooling2D(),
        tf.keras.layers.Dropout(0.3),
        
        # Classification
        tf.keras.layers.Dense(num_classes, activation='softmax')
    ])
    
    # IMPORTANT: Compiler le mod√®le avant conversion
    model.compile(
        optimizer='adam',
        loss='sparse_categorical_crossentropy',
        metrics=['accuracy']
    )
    
    # IMPORTANT: Construire le mod√®le en appelant build()
    model.build((None,) + input_shape)
    
    return model


def convert_to_tflite_compatible(model, output_path):
    """
    Convertit en TFLite avec compatibilit√© maximale
    """
    import tempfile
    import shutil
    
    # Cr√©er un r√©pertoire temporaire
    temp_dir = tempfile.mkdtemp()
    
    try:
        # Sauvegarder d'abord en format SavedModel
        print(f"   Sauvegarde temporaire en SavedModel...")
        model.save(temp_dir, save_format='tf')
        
        # Convertir depuis SavedModel (plus compatible)
        print(f"   Conversion en TFLite...")
        converter = tf.lite.TFLiteConverter.from_saved_model(temp_dir)
        
        # Configuration BASIQUE pour compatibilit√© maximale
        converter.target_spec.supported_ops = [
            tf.lite.OpsSet.TFLITE_BUILTINS,
        ]
        
        # Pas d'optimisations pour √©viter les incompatibilit√©s de version
        # converter.optimizations = [tf.lite.Optimize.DEFAULT]  # D√©sactiv√©
        
        # Convertir
        tflite_model = converter.convert()
        
        # Sauvegarder
        with open(output_path, 'wb') as f:
            f.write(tflite_model)
        
        print(f"‚úì Mod√®le cr√©√©: {os.path.basename(output_path)}")
        print(f"  Taille: {len(tflite_model) / 1024:.1f} KB")
        
        return len(tflite_model)
        
    finally:
        # Nettoyer le r√©pertoire temporaire
        shutil.rmtree(temp_dir, ignore_errors=True)


# 1. Cr√©er le mod√®le boxes
print("1Ô∏è‚É£  Cr√©ation du mod√®le de classification des cases...")
print("   Architecture: CNN simple (ultra-compatible)")
print()

old_boxes_path = os.path.join(models_dir, 'ttt-boxes.tflite')
if os.path.exists(old_boxes_path):
    backup_path = os.path.join(models_dir, 'ttt-boxes-OLD.tflite')
    if not os.path.exists(backup_path):
        os.rename(old_boxes_path, backup_path)
        print(f"   ‚Ü™ Ancien mod√®le sauvegard√©: {os.path.basename(backup_path)}")

boxes_model = create_simple_model(num_classes=3, input_shape=(224, 224, 3))
print(f"   Param√®tres: {boxes_model.count_params():,}")
size_boxes = convert_to_tflite_compatible(boxes_model, old_boxes_path)
print()


# 2. Cr√©er le mod√®le valid
print("2Ô∏è‚É£  Cr√©ation du mod√®le de validation du plateau...")
print("   Architecture: CNN simple (ultra-compatible)")
print()

old_valid_path = os.path.join(models_dir, 'ttt-valid-board.tflite')
if os.path.exists(old_valid_path):
    backup_path = os.path.join(models_dir, 'ttt-valid-board-OLD.tflite')
    if not os.path.exists(backup_path):
        os.rename(old_valid_path, backup_path)
        print(f"   ‚Ü™ Ancien mod√®le sauvegard√©: {os.path.basename(backup_path)}")

valid_model = create_simple_model(num_classes=2, input_shape=(224, 224, 3))
print(f"   Param√®tres: {valid_model.count_params():,}")
size_valid = convert_to_tflite_compatible(valid_model, old_valid_path)
print()


# 3. Tester
print("3Ô∏è‚É£  Test de compatibilit√©...")

try:
    import tensorflow.lite as tflite
    
    interpreter = tflite.Interpreter(old_boxes_path)
    interpreter.allocate_tensors()
    print("   ‚úì ttt-boxes.tflite fonctionne ‚úÖ")
except Exception as e:
    print(f"   ‚ùå ttt-boxes.tflite: {e}")

try:
    interpreter = tflite.Interpreter(old_valid_path)
    interpreter.allocate_tensors()
    print("   ‚úì ttt-valid-board.tflite fonctionne ‚úÖ")
except Exception as e:
    print(f"   ‚ùå ttt-valid-board.tflite: {e}")

print()
print("="*70)
print("‚úÖ Mod√®les ultra-compatibles cr√©√©s !")
print("="*70)
print()
print(f"üìä Taille totale: {(size_boxes + size_valid) / 1024:.1f} KB")
print()
print("‚ö†Ô∏è  IMPORTANT:")
print("   Ces mod√®les sont basiques (CNN simple) et NON entra√Æn√©s.")
print("   Ils donneront des r√©sultats al√©atoires sans entra√Ænement.")
print()
print("   Pour une VRAIE d√©tection, vous DEVEZ les entra√Æner avec vos donn√©es:")
print("   1. Collectez des images: notebooks/Collect_training_images.ipynb")
print("   2. Entra√Ænez: notebooks/Train_classifier.ipynb")
print()
print("Vous pouvez maintenant relancer le jeu pour tester le syst√®me:")
print("   python -m reachy_tictactoe.game_launcher --log-file /tmp/tictactoe")
print()