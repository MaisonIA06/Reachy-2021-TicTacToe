#!/usr/bin/env python3
"""
Script pour cr√©er des mod√®les TFLite ultra-simples (√©vite les bugs Keras 3)
"""

import os
import sys
import numpy as np

try:
    import tensorflow as tf
except ImportError:
    print("‚ùå TensorFlow n'est pas install√©.")
    sys.exit(1)

print("="*70)
print("Cr√©ation de mod√®les TFLite ultra-simples")
print(f"TensorFlow version: {tf.__version__}")
print("="*70)
print()

# Chemins
script_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(script_dir)
models_dir = os.path.join(project_dir, 'reachy_tictactoe', 'models')

print(f"üìÅ R√©pertoire des mod√®les: {models_dir}")
print()


def create_simple_model(num_classes, input_shape=(224, 224, 3)):
    """
    Cr√©e un mod√®le CNN TR√àS simple sans Dropout (√©vite les bugs TFLite)
    """
    model = tf.keras.Sequential([
        tf.keras.layers.Input(shape=input_shape),
        
        # Bloc 1 - Simple
        tf.keras.layers.Conv2D(16, 3, activation='relu', padding='same'),
        tf.keras.layers.MaxPooling2D(2),
        
        # Bloc 2 - Simple
        tf.keras.layers.Conv2D(32, 3, activation='relu', padding='same'),
        tf.keras.layers.MaxPooling2D(2),
        
        # Bloc 3 - Simple
        tf.keras.layers.Conv2D(64, 3, activation='relu', padding='same'),
        tf.keras.layers.GlobalAveragePooling2D(),
        
        # Classification
        tf.keras.layers.Dense(num_classes, activation='softmax')
    ])
    
    # Compiler le mod√®le
    model.compile(
        optimizer='adam',
        loss='sparse_categorical_crossentropy',
        metrics=['accuracy']
    )
    
    # IMPORTANT: Initialiser le mod√®le avec un appel fictif
    # Cela initialise tous les poids et √©vite les bugs de conversion
    dummy_input = tf.random.normal([1, 224, 224, 3])
    _ = model(dummy_input, training=False)
    
    return model


def convert_to_tflite_simple(model, output_path):
    """
    Conversion TFLite la plus simple possible
    """
    try:
        print(f"   Conversion directe en TFLite...")
        
        # Conversion DIRECTE sans SavedModel (plus fiable)
        converter = tf.lite.TFLiteConverter.from_keras_model(model)
        
        # Configuration minimale
        converter.target_spec.supported_ops = [
            tf.lite.OpsSet.TFLITE_BUILTINS,
        ]
        
        # Pas d'optimisations
        # converter.optimizations = [tf.lite.Optimize.DEFAULT]
        
        # Convertir
        tflite_model = converter.convert()
        
        # Sauvegarder
        with open(output_path, 'wb') as f:
            f.write(tflite_model)
        
        print(f"‚úì Mod√®le cr√©√©: {os.path.basename(output_path)}")
        print(f"  Taille: {len(tflite_model) / 1024:.1f} KB")
        
        return len(tflite_model)
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la conversion: {e}")
        print()
        print("Tentative avec m√©thode alternative (fichier .keras)...")
        
        # M√©thode alternative : sauvegarder en .keras puis convertir
        import tempfile
        temp_file = tempfile.NamedTemporaryFile(suffix='.keras', delete=False)
        temp_path = temp_file.name
        temp_file.close()
        
        try:
            # Sauvegarder en format .keras
            model.save(temp_path)
            
            # Recharger
            loaded_model = tf.keras.models.load_model(temp_path)
            
            # Convertir
            converter = tf.lite.TFLiteConverter.from_keras_model(loaded_model)
            converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS]
            tflite_model = converter.convert()
            
            # Sauvegarder
            with open(output_path, 'wb') as f:
                f.write(tflite_model)
            
            print(f"‚úì Mod√®le cr√©√© (m√©thode alternative): {os.path.basename(output_path)}")
            print(f"  Taille: {len(tflite_model) / 1024:.1f} KB")
            
            return len(tflite_model)
            
        finally:
            # Nettoyer
            if os.path.exists(temp_path):
                os.unlink(temp_path)


# 1. Cr√©er le mod√®le boxes
print("1Ô∏è‚É£  Cr√©ation du mod√®le de classification des cases...")
print("   Architecture: CNN ultra-simple (pas de Dropout)")
print()

old_boxes_path = os.path.join(models_dir, 'ttt-boxes.tflite')
if os.path.exists(old_boxes_path):
    backup_path = os.path.join(models_dir, 'ttt-boxes-OLD.tflite')
    if not os.path.exists(backup_path):
        os.rename(old_boxes_path, backup_path)
        print(f"   ‚Ü™ Ancien mod√®le sauvegard√©: {os.path.basename(backup_path)}")

boxes_model = create_simple_model(num_classes=3, input_shape=(224, 224, 3))
print(f"   Param√®tres: {boxes_model.count_params():,}")
size_boxes = convert_to_tflite_simple(boxes_model, old_boxes_path)
print()


# 2. Cr√©er le mod√®le valid
print("2Ô∏è‚É£  Cr√©ation du mod√®le de validation du plateau...")
print("   Architecture: CNN ultra-simple (pas de Dropout)")
print()

old_valid_path = os.path.join(models_dir, 'ttt-valid-board.tflite')
if os.path.exists(old_valid_path):
    backup_path = os.path.join(models_dir, 'ttt-valid-board-OLD.tflite')
    if not os.path.exists(backup_path):
        os.rename(old_valid_path, backup_path)
        print(f"   ‚Ü™ Ancien mod√®le sauvegard√©: {os.path.basename(backup_path)}")

valid_model = create_simple_model(num_classes=2, input_shape=(224, 224, 3))
print(f"   Param√®tres: {valid_model.count_params():,}")
size_valid = convert_to_tflite_simple(valid_model, old_valid_path)
print()


# 3. Tester les mod√®les
print("3Ô∏è‚É£  Test de compatibilit√©...")

success_count = 0

try:
    interpreter = tf.lite.Interpreter(old_boxes_path)
    interpreter.allocate_tensors()
    print("   ‚úì ttt-boxes.tflite fonctionne ‚úÖ")
    success_count += 1
except Exception as e:
    print(f"   ‚ùå ttt-boxes.tflite: {e}")

try:
    interpreter = tf.lite.Interpreter(old_valid_path)
    interpreter.allocate_tensors()
    print("   ‚úì ttt-valid-board.tflite fonctionne ‚úÖ")
    success_count += 1
except Exception as e:
    print(f"   ‚ùå ttt-valid-board.tflite: {e}")

print()

if success_count == 2:
    print("="*70)
    print("‚úÖ Mod√®les ultra-simples cr√©√©s avec succ√®s !")
    print("="*70)
    print()
    print(f"üìä Taille totale: {(size_boxes + size_valid) / 1024:.1f} KB")
    print()
    print("‚ö†Ô∏è  IMPORTANT:")
    print("   Ces mod√®les sont ultra-basiques et NON entra√Æn√©s.")
    print("   Ils permettent de TESTER le syst√®me sans erreur.")
    print("   La d√©tection sera al√©atoire jusqu'√† ce que vous les entra√Æniez.")
    print()
    print("   Pour une VRAIE d√©tection:")
    print("   1. Collectez des images: notebooks/Collect_training_images.ipynb")
    print("   2. Entra√Ænez: notebooks/Train_classifier.ipynb")
    print()
    print("Vous pouvez maintenant tester le syst√®me:")
    print("   python -m reachy_tictactoe.game_launcher --log-file /tmp/tictactoe")
    print()
else:
    print("="*70)
    print("‚ö†Ô∏è  Certains mod√®les ont √©chou√©")
    print("="*70)
    print()
    print("Les mod√®les n'ont pas pu √™tre cr√©√©s correctement.")
    print("Cela peut √™tre d√ª √† un probl√®me de version de TensorFlow.")
    print()