#!/usr/bin/env python3
"""
Script pour cr√©er des mod√®les TFLite en utilisant le format .h5 (plus compatible)
√Ä ex√©cuter sur votre PC, puis transf√©rer les .tflite vers Reachy
"""

import os
import sys
import numpy as np

try:
    import tensorflow as tf
except ImportError:
    print("‚ùå TensorFlow n'est pas install√©.")
    print("Installez-le avec: pip install tensorflow")
    sys.exit(1)

print("="*70)
print("Cr√©ation de mod√®les TFLite via format H5")
print(f"TensorFlow version: {tf.__version__}")
print("="*70)
print()

# Chemins
script_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(script_dir)
models_dir = os.path.join(project_dir, 'reachy_tictactoe', 'models')

print(f"üìÅ R√©pertoire des mod√®les: {models_dir}")
print()


def create_model_functional(num_classes, input_shape=(224, 224, 3)):
    """
    Cr√©e un mod√®le en API fonctionnelle (plus compatible que Sequential)
    """
    inputs = tf.keras.Input(shape=input_shape)
    
    # Bloc 1
    x = tf.keras.layers.Conv2D(16, 3, activation='relu', padding='same')(inputs)
    x = tf.keras.layers.MaxPooling2D(2)(x)
    
    # Bloc 2
    x = tf.keras.layers.Conv2D(32, 3, activation='relu', padding='same')(x)
    x = tf.keras.layers.MaxPooling2D(2)(x)
    
    # Bloc 3
    x = tf.keras.layers.Conv2D(64, 3, activation='relu', padding='same')(x)
    x = tf.keras.layers.GlobalAveragePooling2D()(x)
    
    # Classification
    outputs = tf.keras.layers.Dense(num_classes, activation='softmax')(x)
    
    model = tf.keras.Model(inputs=inputs, outputs=outputs)
    
    # Compiler
    model.compile(
        optimizer='adam',
        loss='sparse_categorical_crossentropy',
        metrics=['accuracy']
    )
    
    return model


def convert_via_h5(model, output_path):
    """
    Convertit en TFLite via fichier .h5 (m√©thode la plus stable)
    """
    import tempfile
    
    # Cr√©er un fichier temporaire .h5
    temp_h5 = tempfile.NamedTemporaryFile(suffix='.h5', delete=False)
    temp_h5.close()
    
    try:
        print(f"   Sauvegarde en format H5...")
        # Sauvegarder en H5 (ancien format, tr√®s compatible)
        model.save(temp_h5.name, save_format='h5')
        
        print(f"   Rechargement du mod√®le H5...")
        # Recharger le mod√®le
        loaded_model = tf.keras.models.load_model(temp_h5.name)
        
        print(f"   Conversion en TFLite...")
        # Convertir
        converter = tf.lite.TFLiteConverter.from_keras_model(loaded_model)
        converter.target_spec.supported_ops = [tf.lite.OpsSet.TFLITE_BUILTINS]
        
        tflite_model = converter.convert()
        
        # Sauvegarder
        with open(output_path, 'wb') as f:
            f.write(tflite_model)
        
        print(f"‚úì Mod√®le cr√©√©: {os.path.basename(output_path)}")
        print(f"  Taille: {len(tflite_model) / 1024:.1f} KB")
        
        return len(tflite_model)
        
    except Exception as e:
        print(f"‚ùå Erreur: {e}")
        raise
        
    finally:
        # Nettoyer
        if os.path.exists(temp_h5.name):
            os.unlink(temp_h5.name)


# 1. Cr√©er le mod√®le boxes
print("1Ô∏è‚É£  Cr√©ation du mod√®le de classification des cases...")
print("   Architecture: CNN simple en API fonctionnelle")
print()

old_boxes_path = os.path.join(models_dir, 'ttt-boxes.tflite')
if os.path.exists(old_boxes_path):
    backup_path = os.path.join(models_dir, 'ttt-boxes-OLD2.tflite')
    if not os.path.exists(backup_path):
        os.rename(old_boxes_path, backup_path)
        print(f"   ‚Ü™ Ancien mod√®le sauvegard√©: {os.path.basename(backup_path)}")

boxes_model = create_model_functional(num_classes=3, input_shape=(224, 224, 3))
print(f"   Param√®tres: {boxes_model.count_params():,}")
size_boxes = convert_via_h5(boxes_model, old_boxes_path)
print()


# 2. Cr√©er le mod√®le valid
print("2Ô∏è‚É£  Cr√©ation du mod√®le de validation du plateau...")
print("   Architecture: CNN simple en API fonctionnelle")
print()

old_valid_path = os.path.join(models_dir, 'ttt-valid-board.tflite')
if os.path.exists(old_valid_path):
    backup_path = os.path.join(models_dir, 'ttt-valid-board-OLD2.tflite')
    if not os.path.exists(backup_path):
        os.rename(old_valid_path, backup_path)
        print(f"   ‚Ü™ Ancien mod√®le sauvegard√©: {os.path.basename(backup_path)}")

valid_model = create_model_functional(num_classes=2, input_shape=(224, 224, 3))
print(f"   Param√®tres: {valid_model.count_params():,}")
size_valid = convert_via_h5(valid_model, old_valid_path)
print()


# 3. Tester
print("3Ô∏è‚É£  Test de compatibilit√©...")

success_count = 0

try:
    interpreter = tf.lite.Interpreter(old_boxes_path)
    interpreter.allocate_tensors()
    print("   ‚úì ttt-boxes.tflite fonctionne ‚úÖ")
    success_count += 1
except Exception as e:
    print(f"   ‚ùå ttt-boxes.tflite: {e}")

try:
    interpreter = tf.lite.Interpreter(old_valid_path)
    interpreter.allocate_tensors()
    print("   ‚úì ttt-valid-board.tflite fonctionne ‚úÖ")
    success_count += 1
except Exception as e:
    print(f"   ‚ùå ttt-valid-board.tflite: {e}")

print()

if success_count == 2:
    print("="*70)
    print("‚úÖ Mod√®les cr√©√©s avec succ√®s !")
    print("="*70)
    print()
    print(f"üìä Taille totale: {(size_boxes + size_valid) / 1024:.1f} KB")
    print()
    print("üì§ TRANSF√âRER LES MOD√àLES VERS REACHY:")
    print()
    print("   scp reachy_tictactoe/models/ttt-boxes.tflite \\")
    print("       reachy@<IP>:~/dev/Reachy-2021-TicTacToe/reachy_tictactoe/models/")
    print()
    print("   scp reachy_tictactoe/models/ttt-valid-board.tflite \\")
    print("       reachy@<IP>:~/dev/Reachy-2021-TicTacToe/reachy_tictactoe/models/")
    print()
    print("‚ö†Ô∏è  Ces mod√®les sont NON entra√Æn√©s (d√©tection al√©atoire).")
    print("   Entra√Ænez-les avec vos donn√©es pour une vraie d√©tection.")
    print()
else:
    print("‚ö†Ô∏è  Certains mod√®les ont √©chou√©.")
    print()