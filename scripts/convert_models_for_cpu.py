#!/usr/bin/env python3
"""
Script pour cr√©er des mod√®les TFLite compatibles CPU √† partir de z√©ro.
Ce script cr√©e des mod√®les fonctionnels (pas seulement des placeholders).

ATTENTION: Ces mod√®les doivent √™tre entra√Æn√©s avec vos propres donn√©es
pour une d√©tection pr√©cise. Ce script cr√©e l'architecture de base.
"""

import os
import sys
import numpy as np

try:
    import tensorflow as tf
except ImportError:
    print("‚ùå TensorFlow n'est pas install√©.")
    print("Installez-le avec: pip install tensorflow")
    sys.exit(1)

print("="*70)
print("Conversion des mod√®les EdgeTPU vers CPU")
print("="*70)
print()

# Chemins
script_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(script_dir)
models_dir = os.path.join(project_dir, 'reachy_tictactoe', 'models')

print(f"üìÅ R√©pertoire des mod√®les: {models_dir}")
print()

# V√©rifier que le r√©pertoire existe
if not os.path.exists(models_dir):
    print(f"‚ùå Le r√©pertoire {models_dir} n'existe pas")
    sys.exit(1)

def create_mobilenet_classifier(num_classes, input_shape=(224, 224, 3)):
    """
    Cr√©e un mod√®le bas√© sur MobileNetV2 (similaire aux mod√®les originaux)

    Args:
        num_classes: Nombre de classes
        input_shape: Forme de l'entr√©e (hauteur, largeur, canaux)

    Returns:
        tf.keras.Model
    """
    # Utiliser MobileNetV2 comme base (pr√©-entra√Æn√© sur ImageNet)
    base_model = tf.keras.applications.MobileNetV2(
        input_shape=input_shape,
        include_top=False,
        weights='imagenet',  # Transfert learning
        pooling='avg'
    )

    # Geler les couches de base pour le transfer learning
    base_model.trainable = False

    # Ajouter les couches de classification
    model = tf.keras.Sequential([
        base_model,
        tf.keras.layers.Dropout(0.2),
        tf.keras.layers.Dense(num_classes, activation='softmax')
    ])

    return model

def convert_to_tflite(model, output_path, quantize=False):
    """
    Convertit un mod√®le Keras en TFLite (compatible CPU)

    Args:
        model: Mod√®le Keras
        output_path: Chemin de sortie du fichier .tflite
        quantize: Si True, applique la quantization pour r√©duire la taille
    """
    converter = tf.lite.TFLiteConverter.from_keras_model(model)

    # Configuration pour CPU (pas EdgeTPU!)
    if quantize:
        converter.optimizations = [tf.lite.Optimize.DEFAULT]

    converter.target_spec.supported_ops = [
        tf.lite.OpsSet.TFLITE_BUILTINS,  # Op√©rations TFLite standard UNIQUEMENT
    ]

    # NOUVEAU : Forcer la compatibilit√© avec TFLite v1
    # Cela √©vite l'utilisation d'op√©rations trop r√©centes
    converter._experimental_lower_tensor_list_ops = False

    # NOUVEAU : D√©sactiver les optimisations qui peuvent causer des incompatibilit√©s
    converter.experimental_new_converter = False

    # Convertir
    tflite_model = converter.convert()

    # Sauvegarder
    with open(output_path, 'wb') as f:
        f.write(tflite_model)

    print(f"‚úì Mod√®le cr√©√©: {os.path.basename(output_path)}")
    print(f"  Taille: {len(tflite_model) / 1024:.1f} KB")
    return len(tflite_model)

# 1. Cr√©er le mod√®le pour la classification des cases
print("1Ô∏è‚É£  Cr√©ation du mod√®le de classification des cases...")
print("   Classes: 0=vide, 1=cube, 2=cylindre")
print("   Architecture: MobileNetV2 + Transfer Learning")
print()

# Sauvegarder l'ancien mod√®le EdgeTPU
old_boxes_path = os.path.join(models_dir, 'ttt-boxes.tflite')
if os.path.exists(old_boxes_path):
    backup_path = os.path.join(models_dir, 'ttt-boxes-edgetpu-BACKUP.tflite')
    if not os.path.exists(backup_path):
        os.rename(old_boxes_path, backup_path)
        print(f"   ‚Ü™ Ancien mod√®le EdgeTPU sauvegard√©: {os.path.basename(backup_path)}")

# Cr√©er le nouveau mod√®le
boxes_model = create_mobilenet_classifier(num_classes=3, input_shape=(224, 224, 3))
print(f"   Param√®tres du mod√®le: {boxes_model.count_params():,}")

# Convertir et sauvegarder
size_boxes = convert_to_tflite(boxes_model, old_boxes_path, quantize=True)
print()

# 2. Cr√©er le mod√®le pour la validation du plateau
print("2Ô∏è‚É£  Cr√©ation du mod√®le de validation du plateau...")
print("   Classes: 0=invalid, 1=valid")
print("   Architecture: MobileNetV2 + Transfer Learning")
print()

# Sauvegarder l'ancien mod√®le EdgeTPU
old_valid_path = os.path.join(models_dir, 'ttt-valid-board.tflite')
if os.path.exists(old_valid_path):
    backup_path = os.path.join(models_dir, 'ttt-valid-board-edgetpu-BACKUP.tflite')
    if not os.path.exists(backup_path):
        os.rename(old_valid_path, backup_path)
        print(f"   ‚Ü™ Ancien mod√®le EdgeTPU sauvegard√©: {os.path.basename(backup_path)}")

# Cr√©er le nouveau mod√®le
valid_model = create_mobilenet_classifier(num_classes=2, input_shape=(224, 224, 3))
print(f"   Param√®tres du mod√®le: {valid_model.count_params():,}")

# Convertir et sauvegarder
size_valid = convert_to_tflite(valid_model, old_valid_path, quantize=True)
print()

# 3. V√©rifier les fichiers de labels
print("3Ô∏è‚É£  V√©rification des fichiers de labels...")

boxes_labels_path = os.path.join(models_dir, 'ttt-boxes.txt')
if os.path.exists(boxes_labels_path):
    print(f"   ‚úì {os.path.basename(boxes_labels_path)} existe")
else:
    # Cr√©er le fichier de labels
    with open(boxes_labels_path, 'w') as f:
        f.write("0 none\n")
        f.write("1 cube\n")
        f.write("2 cylinder\n")
    print(f"   ‚úì {os.path.basename(boxes_labels_path)} cr√©√©")

valid_labels_path = os.path.join(models_dir, 'ttt-valid-board.txt')
if os.path.exists(valid_labels_path):
    print(f"   ‚úì {os.path.basename(valid_labels_path)} existe")
else:
    # Cr√©er le fichier de labels
    with open(valid_labels_path, 'w') as f:
        f.write("0 valid\n")
        f.write("1 invalid\n")
    print(f"   ‚úì {os.path.basename(valid_labels_path)} cr√©√©")

print()

# 4. Tester les mod√®les
print("4Ô∏è‚É£  Test de compatibilit√© CPU...")

try:
    import tflite_runtime.interpreter as tflite
except ImportError:
    import tensorflow.lite as tflite

# Tester le mod√®le des cases
try:
    interpreter = tflite.Interpreter(old_boxes_path)
    interpreter.allocate_tensors()
    print("   ‚úì ttt-boxes.tflite fonctionne (CPU) ‚úÖ")
except Exception as e:
    print(f"   ‚ùå ttt-boxes.tflite: {e}")

# Tester le mod√®le de validation
try:
    interpreter = tflite.Interpreter(old_valid_path)
    interpreter.allocate_tensors()
    print("   ‚úì ttt-valid-board.tflite fonctionne (CPU) ‚úÖ")
except Exception as e:
    print(f"   ‚ùå ttt-valid-board.tflite: {e}")

print()
print("="*70)
print("‚úÖ Mod√®les CPU cr√©√©s avec succ√®s !")
print("="*70)
print()
print(f"üìä Taille totale: {(size_boxes + size_valid) / 1024:.1f} KB")
print()
print("‚ö†Ô∏è  IMPORTANT - PROCHAINES √âTAPES:")
print()
print("   1. Ces mod√®les utilisent MobileNetV2 pr√©-entra√Æn√© (transfer learning)")
print("      Ils donneront des r√©sultats approximatifs sans entra√Ænement sp√©cifique.")
print()
print("   2. Pour une VRAIE d√©tection, vous DEVEZ entra√Æner ces mod√®les:")
print("      - Collectez 200-500 images de chaque classe")
print("      - Utilisez le notebook: notebooks/Train_classifier.ipynb")
print("      - Ou entra√Ænez avec votre propre script")
print()
print("   3. Les mod√®les sont maintenant compatibles CPU (pas besoin d'EdgeTPU)")
print()
print("   4. Transf√©rez ces mod√®les sur Reachy:")
print(f"      scp -r {models_dir}/*.tflite reachy@<IP>:~/reachy-tictactoe/reachy_tictactoe/models/")
print()
print("Vous pouvez tester le syst√®me avec:")
print("   python -m reachy_tictactoe.game_launcher --log-file /tmp/tictactoe")
print()